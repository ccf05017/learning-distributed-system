# 2계층 산출물 템플릿 (Layer 0 + Layer 1)

## Layer 1: Skill Spec (AI 적용용 컨텍스트 패키지)
### 0) Mode (이 Skill의 성격)
- [x] Decision Skill (도입 판단/설계 선택지 확장)
- [ ] Implementation Skill (구현 재현/세부 설계)

### 1) Skill ID / 한 줄 정의
- Skill ID: storage.record-framing.decision-v1
- 한 줄 정의:
  - “바이트 스트림(파일/소켓)에서 레코드 경계/손상/부분 기록 문제가 있을 때, newline 기반 대신 length-prefix framing을 도입할지 판단하고 최소 포맷/검증 시나리오를 제시하는 절차”

### 2) Trigger (언제 이 스킬을 꺼내 쓰나)
- 적용 상황(증상/요구):
  - “구분자(`\\n`) 기반 파싱이 바이너리/특수문자와 충돌한다”
  - “크래시/부분 쓰기로 파일 끝이 잘리고 복구가 불안정하다”
  - “파서가 입력 손상에 취약하거나 폭주 length로 OOM/시간 폭주가 난다”
- 포함 조건(이 스킬이 유효한 범위):
  - “레코드 크기 상한을 둘 수 있음”
  - “손상 데이터를 만나면 ‘정책대로 안전하게 실패’하는 게 목표”
- 제외 조건(다른 스킬/설계를 써야 하는 경우):
  - “자기동기화(resync)가 반드시 필요(임의 오프셋에서 스캔 복구가 핵심)”
  - “포맷 호환(버전/스키마 진화)이 최우선”

### 3) Inputs (AI에게 제공해야 하는 입력)
- 필수 입력:
  - 레코드 크기 상한(최대 bytes)
  - 무결성 방식(없음/CRC32/SHA 등)과 실패 시 정책(중단/스킵/격리)
  - 엔디안/정수 크기(예: u32 little-endian)
  - 중간 손상에서의 정책: prefix만 신뢰하고 중단? 스킵/격리까지 할 건가?
- 선택 입력(있으면 정확도가 크게 오르는 것):
  - 손상 데이터 재현 바이트(샘플)
  - 운영 환경(파일시스템/네트워크/메모리 제한)
- 입력이 불충분할 때 AI가 해야 할 일(기본 정책):
  - “상한/정수 크기/엔디안을 가정으로 명시하고, 가정별 포맷을 분리”

### 4) Outputs (AI가 만들어야 하는 산출물)
- 산출물 타입(해당되는 것만 선택):
  - [x] 도입 판단(추천/보류/비추천 + 근거)
  - [x] 설계 선택지(최소 포맷 + 정책)
  - [x] 검증 시나리오(프로젝트-중립 템플릿)
- 성공 기준(명시적으로):
  - “tail partial/손상/폭주 length에서 정책대로 안전하게 동작(침묵 오류 없음)”

### 5) Invariants & Constraints (절대 조건 / 제약)
- 절대 불변조건(깨지면 실패):
  - “길이 필드는 상한을 갖는다(최대 레코드 크기)”
  - “남은 바이트 < len 이면 tail partial로 판단하고 정책대로 중단/무시”
  - “무결성 실패 시 명시 정책 적용(침묵 스킵 금지)”
- 제약 조건:
  - 프레이밍은 “파싱 안정성” 레이어이며, 커밋/내구성 계약은 별도로 정의해야 함
- 허용되는 트레이드오프(명시):
  - “중간 손상에서 ‘계속 진행’ 대신 prefix만 신뢰하고 중단(단순/안전)”

### 6) Procedure (AI가 따라야 할 절차 / 체크리스트)
1. 현재 프레이밍의 실패모드를 관찰(구분자 충돌, tail partial, 손상 시 중단 위치)
2. 도입 후보를 비교:
   - newline-delimited(단순하지만 텍스트 안전성 요구)
   - length-prefix framing(경계 명확, tail partial 처리 명확)
   - 블록/세그먼트 기반(자기동기화/resync가 필요하면)
3. length-prefix를 선택하면 최소 포맷을 고정: `[len][payload][checksum?]`
4. 상한/엔디안/정수 크기/정책(중단 vs 스킵)을 문장으로 고정
5. 최소 검증 시나리오 3~5개를 작성(아래 Verification 템플릿)

### 7) Verification (검증: 반드시 통과해야 하는 것)
- 필수 검증 시나리오(프로젝트-중립 템플릿):
  - 정상: N개 레코드 쓰고 전부 읽힘
  - tail partial: 마지막 레코드만 정책대로 무시/중단, 앞 레코드는 보존
  - checksum 불일치: 정책대로 중단(기본) 또는 스킵(선택 시) + 회귀
  - 폭주 length: 즉시 실패(메모리/시간 폭주 없음)
- 테스트가 보장하지 못하는 것(과신 방지, 1~2줄):
  - “중간 손상 이후 resync까지 보장하려면 별도 동기 마커/블록 설계가 필요”

### 8) Failure Modes & Debug (실패 모드 / 디버깅 지침)
- Top 실패 모드 1: 폭주 length로 OOM/시간 폭주
  - 증상: 파서가 메모리 할당/읽기에서 멈춤
  - 가능한 원인(가설 3개):
    1) 최대 레코드 크기 상한 없음
    2) len 파싱 엔디안/크기 불일치
    3) 손상 데이터가 len 영역에 들어감
  - 확인 순서(최소 단계):
    1) len 값을 로그로 출력(바이트 덤프)
    2) 상한 비교가 있는지 확인
    3) 상한 초과 입력으로 회귀 테스트 추가
- Top 실패 모드 2: tail partial에서 prefix까지 잃음
  - 증상: 마지막이 끊겼는데 앞 레코드도 안 읽힘
  - 가능한 원인(가설 3개):
    1) 읽기 루프가 예외를 전파하면서 prefix를 반환하지 않음
    2) checksum/길이 검증을 “적용”과 섞어 처리
    3) 버퍼 처리 실수
  - 확인 순서(최소 단계):
    1) “몇 번째 레코드에서 멈췄는지” 로그
    2) partial을 ‘정상 종료’로 취급할지 정책을 고정

### 9) Anti-patterns (금지 패턴)
- 금지 1: 길이 상한 없이 `len`만 믿고 읽기/할당
- 금지 2: 손상 레코드를 침묵 스킵하고 계속 진행(정책 없이)
- 금지 3: 프레이밍을 동시성/커밋 의미의 해결책으로 과대평가

### 10) Prompt Capsule (AI에게 붙여넣는 최적 요청문)
- 캡슐 프롬프트 1: “도입 판단/설계 선택지 확장형”
  - 템플릿:
    - “현재 레코드 포맷(구분자/길이 등), 최대 레코드 크기, 무결성 방식, 손상 시 정책(중단/스킵), 그리고 발생한 실패 증상을 줄게.
      이 상황에서 length-prefix framing을 도입하는 게 적절한지 판단해줘.
      (1) 추천/보류/비추천 결론, (2) 최소 포맷(`[len][payload][checksum?]`) 제안, (3) 필수 회귀 테스트( tail partial/폭주 length/체크섬 불일치 ) 템플릿까지 제시해줘.”
- AI 금지 행동(명시):
  - “상한 없는 설계를 제안”
  - “손상 레코드 스킵을 기본값으로 단정”

### 11) Minimal Examples (최소 예제)
- 성공 예제(입력 → 기대 결과):
  - 입력: `[len=5]['hello']` 레코드 3개 연속
  - 기대 결과: 3개 모두 읽힘
  - 체크 포인트: len 상한 내, checksum 일치
- 실패 예제(입력 → 실패 양상 → 기대 처리):
  - 입력: `[len=10]['abc']` (payload 부족)
  - 실패 양상: tail partial
  - 기대 처리: 정책대로 중단/무시(앞 레코드는 보존)

