# 2계층 산출물 템플릿 (Layer 0 + Layer 1)

## Layer 1: Skill Spec (AI 적용용 컨텍스트 패키지)
### 0) Mode (이 Skill의 성격)
- [x] Decision Skill (도입 판단/설계 선택지 확장)
- [ ] Implementation Skill (구현 재현/세부 설계)

### 1) Skill ID / 한 줄 정의
- Skill ID: storage.wal.decision-v1
- 한 줄 정의:
  - “현재 시스템의 write path/장애 모델/성공(ack) 의미를 바탕으로 WAL(쓰기 전 로그/커밋 경계)을 도입할지 판단하고, 최소 설계 옵션과 검증 시나리오를 제시하는 절차”

### 2) Trigger (언제 이 스킬을 꺼내 쓰나)
- 적용 상황(증상/요구):
  - “재시작/크래시 후에도 ‘성공(ack)’의 결과가 반드시 유지되어야 함”
  - “쓰기 경로가 여러 단계라 중간 실패에서 ‘성공했는데 사라짐/실패했는데 반영됨’ 같은 모순이 생김”
  - “메모리 상태(또는 임시 캐시)에 먼저 반영되지만, 내구성/복구 경로가 없다”
  - “여러 저장소/사이드이펙트(DB write + 이벤트 발행 등)를 함께 수행해야 한다”
- 포함 조건(이 스킬이 유효한 범위):
  - “성공(ack)의 의미를 1문장으로 정의할 수 있다”
  - “장애 모델을 최소 1개는 고정할 수 있다(process kill vs power loss 등)”
  - “쓰기 경로를 단계로 설명할 수 있다(예: validate→append→fsync→apply→ack)”
- 제외 조건(다른 스킬/설계를 써야 하는 경우):
  - “분산 합의/복제가 커밋 의미를 결정한다”
  - “정확히 한 번(exactly-once)이 최우선(중복/재시도 설계가 핵심)”
  - “멀티 writer 고성능(그룹 커밋/백그라운드 flush/락 프리)이 즉시 목표”

### 3) Inputs (AI에게 제공해야 하는 입력)
- 필수 입력:
  - 성공(ack) 의미(테스트 가능 형태): “성공으로 반환된 작업은 재시작 후에도 반드시 관측된다” 같은 1문장
  - 현재 write path 단계(텍스트): validate → log_append → flush → fsync → mem_apply → ack (또는 실제 단계)
  - 장애/실패 모델: process kill? power loss? `fsync` 실패 가능? 재시도는 함?
  - 일관성/가시성 요구: 읽기에서 dirty read 허용? read-your-writes 필요?
  - 제약: 지연/성능 목표, 저장매체/파일시스템, 언어/런타임
- 선택 입력(있으면 정확도가 크게 오르는 것):
  - 이미 쓰는 저장소의 트랜잭션/원자성: DB 트랜잭션, 원자적 rename, 메시지 브로커 트랜잭션 등
  - “로그 포맷/프레이밍” 요구: newline vs length-prefix, checksum/CRC, 최대 레코드 크기
  - 관측 수단: 로그/메트릭(단계별 성공/실패 카운트)
- 입력이 불충분할 때 AI가 해야 할 일(기본 정책):
  - “가정(ack 의미/장애 모델)을 명시하고, 가정별로 결론을 분리”
  - “도입 판단을 위한 최소 검증 시나리오를 먼저 제시”

### 4) Outputs (AI가 만들어야 하는 산출물)
- 산출물 타입(해당되는 것만 선택):
  - [x] 도입 판단(추천/보류/비추천 + 근거)
  - [x] 설계 선택지(최소 설계 + 대안 비교)
  - [x] 검증 시나리오(프로젝트-중립 템플릿)
- 성공 기준(명시적으로):
  - “추천/보류/비추천 결론이 ‘불변조건/실패모드/검증’까지 포함한 근거 기반 결론”
  - “선택한 커밋 규약(ack 의미)이 재시작 시나리오로 검증 가능”

### 5) Invariants & Constraints (절대 조건 / 제약)
- 절대 불변조건(깨지면 실패):
  - “성공 ack의 의미는 재시작 후에도 유지”
  - “커밋 포인트(예: `fsync` 완료/트랜잭션 commit)를 정의하고, 그 이전은 ‘미커밋’으로 취급”
  - “손상/부분 레코드에서 정책(중단/무시)을 명시하고 침묵 오류 금지”
- 제약 조건:
  - process kill(SIGHUP/SIGKILL)은 power loss를 대체하지 못함(불확정 구간 존재)
  - WAL 도입은 보통 “쓰기 비용(추가 I/O)”과 “복구 비용(replay)”을 교환하는 선택
- 허용되는 트레이드오프(명시):
  - “성능보다 ‘성공의 의미(ack)’ 명확화 우선”
  - “단일 writer/락으로 동시성 범위를 제한할 수 있음”

### 6) Procedure (AI가 따라야 할 절차 / 체크리스트)
- 표준 절차(짧고 결정적으로):
  1. “성공 ack의 의미”를 1문장으로 고정(재시작 후 관측까지 포함)
  2. 현재 write path를 단계로 분해하고, 단계별 실패모드를 나열
  3. 도입 후보를 3개 이상으로 확장:
     - (a) WAL + replay(+checkpoint)
     - (b) DB 트랜잭션/원자 연산으로 해결(가능하면 우선)
     - (c) outbox/inbox(“저장 + 이벤트 발행” 원자성이 핵심이면)
     - (d) 단일 writer + 큐(동시성/성능이 핵심이면)
  4. WAL을 선택한다면 최소 설계 옵션을 고정:
     - 커밋 포인트(ack 의미)
     - `fsync` 실패 의미(no-trace vs unknown vs fatal) (참고: `skills/storage/durability-contract/2026-01-11-fsync-failure-contract/meta.md`)
     - 프레이밍/무결성(length-prefix 등) (참고: `skills/storage/record-framing/2026-01-11-length-prefix-framing/meta.md`)
     - 체크포인트/롤링(필요 시)
     - 동시성 모델(단일 writer/락/멀티 writer 금지)
  5. 최소 검증 시나리오 3~5개를 프로젝트-중립 템플릿으로 작성
- 의사결정 분기(필요 시):
  - if “다른 계층이 이미 트랜잭션/원자성을 제공” → WAL을 직접 구현할 필요가 없는지 먼저 검토
  - if “read에서 미커밋 값이 보이면 안 됨” → mem_apply 타이밍/격리 정책을 명시

### 7) Verification (검증: 반드시 통과해야 하는 것)
- 필수 검증 시나리오(프로젝트-중립 템플릿):
  - “성공 ack 후 재시작 → 반드시 반영됨”
  - “ack 전 크래시 → 반영되면 안 됨(또는 계약대로)”
  - “tail partial/손상 데이터 → 정책대로 중단/무시, prefix는 보존”
  - “(선택) checkpoint/롤링 타이밍 크래시 → 중복 적용해도 최종 상태 일치”
- 테스트가 보장하지 못하는 것(과신 방지, 1~2줄):
  - “process kill은 power loss를 완전히 대체하지 못함(커널 버퍼 불확정)”
  - “분산 커밋(쿼럼/합의)은 이 스킬 범위를 벗어남”

### 8) Failure Modes & Debug (실패 모드 / 디버깅 지침)
- Top 실패 모드 1: “프레이밍/파싱이 깨져 replay가 중간에 멈춤”
  - 증상: 로그에는 레코드가 많지만 복구가 중간에서 중단
  - 가능한 원인(가설 3개):
    1) 구분자 기반 파싱과 바이너리/특수문자가 충돌(참고: `write-ahead-log/docs/debugging-lesson-checksum-newline.md`)
    2) tail partial(마지막 레코드가 중간에서 끊김)
    3) 무결성 검증 실패(체크섬 불일치)로 중단 정책 발동
  - 확인 순서(최소 단계):
    1) “기대 레코드 수 vs 실제 경계(라인/길이)” 불일치 확인
    2) 손상 지점 주변 바이트 덤프
    3) 프레이밍/무결성/상한 정책 재검토
  - 수정 후 추가할 회귀 테스트: “대량 기록 + 임의 손상에서 정책대로 중단/무시”
- Top 실패 모드 2: “커밋 의미가 모호(ghost commit / lost commit)”
  - 증상: 실패 반환인데 재시작 후 반영(ghost) 또는 성공 ack인데 재시작 후 누락(lost)
  - 가능한 원인(가설 3개):
    1) `fsync` 실패 의미를 계약으로 고정하지 않음
    2) truncate/rollback 같은 범위 삭제를 동시성에서 사용
    3) mem_apply 타이밍이 가시성/격리 요구와 불일치(dirty read)
  - 확인 순서(최소 단계):
    1) 성공/실패 반환과 재시작 후 관측을 같은 테스트로 묶기
    2) `fsync` 실패 계약(no-trace/unknown/fatal) 문장으로 고정
    3) 동시성 모델(단일 writer 여부) 명시
- Top 실패 모드 3: “체크포인트/롤링 타이밍에서 데이터가 사라짐”
  - 증상: 스냅샷 이후 재시작에서 일부 상태 누락
  - 가능한 원인(가설 3개):
    1) tmp→rename 원자성/에러 처리 누락
    2) 고아 tmp 처리 정책 부재
    3) 로그 삭제/롤링 타이밍 오류
  - 확인 순서(최소 단계):
    1) rename 실패/크래시 타이밍 시나리오를 분리해 테스트
    2) “checkpoint→WAL replay” 순서가 유지되는지 확인

### 9) Anti-patterns (금지 패턴)
- 금지 1: ack 의미를 정의하지 않은 채 “성공”을 반환
- 금지 2: 프레이밍/무결성 정책 없이 “일단 기록하고 스킵하면 됨”으로 처리
- 금지 3: 멀티 writer에서 truncate/rollback을 배타 없이 사용

### 10) Prompt Capsule (AI에게 붙여넣는 최적 요청문)
- 캡슐 프롬프트 1: “도입 판단/설계 선택지 확장형”
  - 템플릿:
    - “현재 시스템의 write path(단계), 성공 ack 의미, 장애 모델(process kill/power loss), `fsync` 실패 가능성, 읽기 일관성 요구를 줄게.
      이 상황에서 WAL(쓰기 전 로그/커밋 경계)을 도입하는 게 적절한지 판단해줘.
      (1) 추천/보류/비추천 결론, (2) 최소 설계 옵션(커밋 포인트/`fsync` 실패 계약/프레이밍/체크포인트/동시성), (3) 대안 2~3개 비교, (4) 최소 검증 시나리오(재시작/크래시/손상)까지 제시해줘.”
- AI 금지 행동(명시):
  - “성공(ack) 의미/장애 모델을 묻지 않고 구현부터 제안”
  - “프레이밍 강화만으로 커밋 의미가 해결된다고 단정”

### 11) Minimal Examples (최소 예제)
- 성공 예제(입력 → 기대 결과):
  - 입력: “성공 ack 반환”된 write 1건 + 즉시 크래시/재시작
  - 기대 결과: 해당 write는 반드시 반영되어야 함
  - 체크 포인트: “성공의 의미”를 재시작 관찰로 잠금
- 실패 예제(입력 → 실패 양상 → 기대 처리):
  - 입력: write path 중간(커밋 포인트 전)에서 크래시
  - 실패 양상: “반영되면 안 되는” 값이 재시작 후 보일 수 있음
  - 기대 처리: 커밋 포인트/정책에 따라 “미커밋은 미반영”을 보장하도록 설계를 수정

