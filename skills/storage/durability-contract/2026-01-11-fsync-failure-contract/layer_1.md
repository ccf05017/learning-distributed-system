# 2계층 산출물 템플릿 (Layer 0 + Layer 1)

## Layer 1: Skill Spec (AI 적용용 컨텍스트 패키지)
### 0) Mode (이 Skill의 성격)
- [x] Decision Skill (도입 판단/설계 선택지 확장)
- [ ] Implementation Skill (구현 재현/세부 설계)

### 1) Skill ID / 한 줄 정의
- Skill ID: storage.durability.fsync-failure-decision-v1
- 한 줄 정의:
  - “`fsync` 실패를 ‘확정 실패(no-trace)’로 강제할지, ‘불확정(unknown)’으로 허용할지, 혹은 ‘fatal’로 처리할지를 계약으로 결정하고 그에 맞는 검증 시나리오를 만드는 절차”

### 2) Trigger (언제 이 스킬을 꺼내 쓰나)
- 적용 상황(증상/요구):
  - “`fsync` 실패 후 재시작 결과가 모호(ghost commit 의심)”
  - “성공(ack) 의미를 ‘durable write’로 두고 싶은데, 실패 시 의미가 정해지지 않음”
  - “rollback/truncate 같은 되돌림을 넣었더니 동시성에서 다른 커밋까지 사라짐”
- 포함 조건(이 스킬이 유효한 범위):
  - “`fsync` 실패가 ‘미기록’임을 보장하지 않는 환경(일반적인 OS/FS)”
  - “재시도/멱등성/가시성 요구를 함께 고려해야 함”
- 제외 조건(다른 스킬/설계를 써야 하는 경우):
  - “이미 상위 계층(트랜잭션/합의)이 커밋 의미를 완전히 정의”
  - “exactly-once가 최우선(별도의 키/프로토콜 설계가 핵심)”

### 3) Inputs (AI에게 제공해야 하는 입력)
- 필수 입력:
  - 성공(ack) 의미(재시작 포함): 성공이면 무엇이 보장되어야 하는가?
  - `fsync` 실패 시 요구: 실패면 “절대 미반영”이어야 하는가, “불확정”을 허용하는가?
  - 재시도 정책: 실패 시 자동 재시도? 사용자가 재시도? 중복 요청이 가능한가?
  - 동시성 모델: 단일 writer인가? 멀티스레드/멀티프로세스를 허용하는가?
- 선택 입력(있으면 정확도가 크게 오르는 것):
  - “실패 반환 직후 파일 내용” 관측 결과(크기/해시/재시작 후 상태)
  - 멱등 키/요청 ID 설계 여부
- 입력이 불충분할 때 AI가 해야 할 일(기본 정책):
  - “no-trace / unknown / fatal 3가지 계약을 분리 제시하고, 각각의 장단점/필요 검증을 같이 제시”

### 4) Outputs (AI가 만들어야 하는 산출물)
- 산출물 타입(해당되는 것만 선택):
  - [x] 도입 판단(계약 선택: no-trace/unknown/fatal + 근거)
  - [x] 설계 선택지(계약별로 필요한 메커니즘/금지사항)
  - [x] 검증 시나리오(재시작 관측 포함 템플릿)
- 성공 기준(명시적으로):
  - “선택한 계약이 재시작 관측 테스트로 표현되고, 모순되는 케이스가 없음”

### 5) Invariants & Constraints (절대 조건 / 제약)
- 절대 불변조건(깨지면 실패):
  - “성공 ack의 의미는 재시작 후에도 유지”
  - “`fsync` 실패 의미는 계약으로 단일하게 정의(애매함 방치 금지)”
- 제약 조건:
  - `fsync` 실패는 ‘미기록’이 아니다(일부/전부 기록되었을 수도 있음)
  - truncate/rollback은 “범위 삭제”라서 공유 파일(멀티 writer)에서 위험
- 허용되는 트레이드오프(명시):
  - no-trace: 결정적 의미를 얻는 대신 구현/동시성 제약이 늘 수 있음
  - unknown: 단순해지지만 재시도/멱등성 설계 비용이 올라감
  - fatal: 단순하지만 운영/가용성 비용이 큼

### 6) Procedure (AI가 따라야 할 절차 / 체크리스트)
1. 계약 후보 3개를 나란히 정의:
   - no-trace: 실패 반환이면 재시작 후에도 절대 반영되면 안 됨
   - unknown: 실패 반환이면 재시작 후 반영될 수도/안 될 수도 있음(대신 재시도는 멱등)
   - fatal: `fsync` 실패 시 더 이상 쓰기를 진행하지 않음(프로세스 종료/쓰기 차단)
2. 각 계약에 대한 “재시작 관측” 시나리오 2~3개를 만든다
3. 동시성 모델을 확정한다(단일 writer vs 멀티 writer)
4. 계약별로 필요한 설계 선택지를 연결한다:
   - no-trace: rollback/truncate(단일 writer 전제) 또는 다른 원자적 커밋 메커니즘 필요
   - unknown: 멱등 키/중복 제거/재시도 규칙을 먼저 설계
   - fatal: 장애 대응/재시작 시 복구 전략을 같이 설계
5. “가장 싫은 실패(ghost commit vs lost commit vs 불확정)”를 기준으로 선택을 고정한다

### 7) Verification (검증: 반드시 통과해야 하는 것)
- 필수 검증 시나리오(계약별 템플릿):
  - no-trace: “`fsync` 실패로 예외 반환 → 재시작 후 그 연산은 절대 보이면 안 됨”
  - unknown: “`fsync` 실패로 예외 반환 → 재시작 후 보일 수도/안 보일 수도 있음, 재시도는 멱등”
  - fatal: “`fsync` 실패 이후 추가 쓰기 금지(동작이 계속되면 실패)”
- 테스트가 보장하지 못하는 것:
  - “SIGKILL은 power loss를 완전히 대체하지 못한다” (참고: `write-ahead-log/docs/crash-test-limitations.md`)

### 8) Failure Modes & Debug (실패 모드 / 디버깅 지침)
- Top 실패 모드 1: ghost commit
  - 증상: 호출 시 실패였는데 재시작 후 반영됨
  - 가능한 원인(가설 3개):
    1) `fsync` 실패를 ‘미기록’으로 오해
    2) 계약이 unknown인데 no-trace로 기대함
    3) 실패 반환/재시작 관측을 한 테스트로 묶지 않음
  - 확인 순서(최소 단계):
    1) 실패 반환 직후 파일 크기/내용을 관측
    2) 재시작 후 replay 결과를 관측
    3) 계약 문장을 1줄로 고정하고 테스트로 잠금
  - 수정 후 추가할 회귀 테스트: “실패 반환 + 재시작 관측” 시나리오
- Top 실패 모드 2: lost commit
  - 증상: 다른 성공 ack가 truncate/rollback 등으로 사라짐
  - 가능한 원인(가설 3개):
    1) 멀티 writer에서 범위 삭제(truncate) 사용
    2) offset/tell 경쟁
    3) 체크포인트/롤링과 writer 동시 실행
  - 확인 순서(최소 단계):
    1) 동시성 재현(참고: `write-ahead-log/scripts/demo_concurrent_rollback_truncation.py`)
    2) 단일 writer/락으로 직렬화했는지 확인
  - 수정 후 추가할 회귀 테스트: “실패한 쓰기가 성공한 쓰기를 삭제하지 않는다”

### 9) Anti-patterns (금지 패턴)
- 금지 1: `fsync` 실패를 ‘확정 실패’로 말하면서 실제로는 파일에 남을 수 있는 상황을 방치
- 금지 2: 프레이밍/체크섬 강화만으로 `fsync` 실패 의미가 해결된다고 착각
- 금지 3: 멀티 writer에서 truncate/rollback을 배타 없이 사용

### 10) Prompt Capsule (AI에게 붙여넣는 최적 요청문)
- 캡슐 프롬프트 1: “도입 판단/계약 선택형”
  - 템플릿:
    - “`fsync` 실패 의미를 계약으로 고정하고 싶다. 성공(ack)의 의미, 장애 모델, 재시도/멱등성 정책, 동시성 모델을 줄 테니
      no-trace/unknown/fatal 3가지 옵션을 비교하고, 내가 선택해야 할 계약을 추천해줘.
      그리고 선택한 계약을 검증하는 ‘실패 반환 + 재시작 관측’ 시나리오 테스트 템플릿을 만들어줘.”
- AI 금지 행동(명시):
  - “`fsync` 실패는 항상 미기록이라고 단정”
  - “동시성 모델을 묻지 않고 truncate/rollback을 추천”

### 11) Minimal Examples (최소 예제)
- 성공 예제(입력 → 기대 결과):
  - 입력: (no-trace 계약) `fsync` 성공 ack 반환
  - 기대 결과: 재시작 후 반드시 반영됨
  - 체크 포인트: “성공=durable” 의미 고정
- 실패 예제(입력 → 실패 양상 → 기대 처리):
  - 입력: `fsync` 실패(예외 반환)
  - 실패 양상: 실제로는 일부/전부 기록됐을 수도 있음(ghost 가능)
  - 기대 처리: 계약에 따라 (a) no-trace면 흔적 0, (b) unknown이면 재시도 멱등, (c) fatal이면 쓰기 중단

