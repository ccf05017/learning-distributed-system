# 디버깅 회고: 체크섬 개행문자 버그

## 문제 상황

동시성 테스트(G3)에서 10 스레드 × 100 쓰기 = 1000 레코드를 기록했으나, WAL 복구 시 25개만 복구됨.

## 잘못된 디버깅 과정

### 1. 성급한 원인 추정
- "동시성 테스트에서 실패 → 동시성 문제"라고 단정
- 테스트 이름/맥락에 휘둘려 lock 문제로 즉시 판단

### 2. 같은 유형의 해결책 반복 적용
- KVStore에 lock 추가 → 실패
- WAL에 lock 추가 → 실패
- close()에 lock 추가 → 실패
- 버퍼링 모드 변경 → 실패
- flush 타이밍 변경 → 실패

**문제점**: 동일한 가설(lock 부족)을 계속 검증하면서, 가설 자체를 의심하지 않음

### 3. 핵심 단서 무시
디버그 출력에서 명확한 단서가 있었음:
```
WAL lines count: 1016
```

**예상값**: 1000 레코드 + 1 빈줄 = 1001줄
**실제값**: 1016줄
**차이**: 15줄 추가

이 불일치를 보고도 "왜 줄 수가 다른가?"를 질문하지 않음.

### 4. 증상과 원인의 혼동
- 증상: 동시 쓰기 시 WAL 손상
- 추정 원인: race condition
- 실제 원인: 직렬화 포맷 버그 (체크섬에 `\n` 포함 가능)

동시성 테스트에서 발견되었지만, 실제로는 데이터 양이 많아지면서 확률적으로 발현된 기존 버그였음.

## 실제 원인

WAL 레코드 포맷:
```
[4바이트 바이너리 체크섬][JSON 페이로드]\n
```

체크섬은 `struct.pack(">I", crc32)` - 4바이트 바이너리.
이 중 `0x0a` (개행문자)가 포함될 수 있음.

**확률 계산**:
- 4바이트 중 하나라도 `0x0a`일 확률: 1 - (255/256)^4 ≈ 1.55%
- 1000 레코드 중 예상 손상: 1000 × 1.55% ≈ **15.5개**

실제로 15개 추가 줄이 발생 → 확률과 정확히 일치.

## 교훈

### 1. 테스트 이름/맥락에 속지 말 것
테스트가 "동시성 테스트"라고 해서 실패 원인이 반드시 동시성 문제는 아님.

### 2. 수치 불일치에 민감할 것
"1016 vs 1001" 같은 불일치는 핵심 단서. 왜 다른지 먼저 규명해야 함.

### 3. 같은 해결책이 반복 실패하면 가설을 의심할 것
lock을 3번 추가해도 안 되면, "lock 부족"이라는 가설 자체가 틀렸을 가능성을 검토.

### 4. 확률적 버그를 인식할 것
- 소규모 테스트: 통과 (체크섬에 `\n` 없음)
- 대규모 테스트: 실패 (1.55% 확률로 발현)

데이터 양이 늘어나면 드문 경로도 실행됨.

### 5. 바이너리와 텍스트 혼용 시 주의
줄 기반 파싱(`\n` 구분자)과 바이너리 데이터(체크섬)를 섞으면 충돌 가능.

## 해결

WAL 파서가 줄(`\n`) 단위로 읽는 구조라면, 레코드 자체가 **텍스트 안전한 바이트열**이어야 한다.

해결책으로 체크섬을 바이너리 4바이트로 붙이는 대신, ASCII hex 헤더로 기록한다:
```
{crc32_hex} {json_payload}\n
```

---

*작성일: 2026-01-10*
