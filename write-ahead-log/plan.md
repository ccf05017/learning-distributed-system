# WAL(Write-Ahead Log) 구현 계획

## 학습 목표
- WAL 기반 단일 노드 KV 스토어를 TDD로 구현하며 분산 시스템의 내구성(durability) 원리를 체득한다
- "로그가 디스크에 안전하게 기록되면 성공(ack)"이라는 커밋 기준을 실험으로 검증한다

---

## Phase 1: 기본 동작 (A 시나리오)
> 메모리 기반 KV 스토어의 기본 CRUD 동작

### 1.1 PUT/GET 기본 (A1)
- [x] 빈 스토어에서 PUT 후 GET으로 값 조회

### 1.2 UPDATE (A2)
- [x] 동일 키에 덮어쓰기 후 최신 값 반환

### 1.3 DELETE (A3)
- [x] 키 삭제 후 존재하지 않음 확인

### 1.4 다중 키 독립성 (A4)
- [x] 여러 키가 서로 독립적으로 동작

---

## Phase 2: WAL 레코드 객체
> 레코드 포맷 정의 및 직렬화/역직렬화 담당

### 2.1 WALRecord 기본 구조
- [ ] 레코드 타입을 구분할 수 있다 (PUT, DEL)
- [ ] 레코드를 바이트로 직렬화할 수 있다
- [ ] 바이트에서 레코드를 역직렬화할 수 있다

### 2.2 레코드 무결성
- [ ] 레코드에 체크섬이 포함된다
- [ ] 역직렬화 시 체크섬으로 손상 여부를 검증한다
- [ ] 손상된 레코드는 오류를 반환한다

### 2.3 레코드 프레이밍
- [ ] 레코드 길이 정보가 포함되어 경계를 알 수 있다
- [ ] 부분 레코드(incomplete)를 감지할 수 있다

---

## Phase 3: WAL 파일 관리 객체
> 파일 I/O 및 레코드 스트림 관리 담당

### 3.1 WAL 쓰기
- [ ] 레코드를 파일에 append할 수 있다
- [ ] flush/fsync로 디스크에 영구 저장할 수 있다
- [ ] 파일을 정상 종료할 수 있다

### 3.2 WAL 읽기
- [ ] 파일에서 레코드를 순차적으로 읽을 수 있다
- [ ] 손상되거나 불완전한 레코드에서 안전하게 중단한다

---

## Phase 4: KVStore와 WAL 통합
> 기존 임시 구현을 WAL 객체로 교체

### 4.1 KVStore가 WAL 객체를 사용한다
- [x] PUT 수행 시 WAL 파일에 레코드가 기록된다 (임시 구현)
- [x] DEL 수행 시 WAL 파일에 레코드가 기록된다 (임시 구현)
- [x] 정상 종료 시 버퍼의 모든 데이터가 디스크에 flush되고 파일이 닫힌다 (임시 구현)
- [ ] 임시 구현을 WAL 객체로 교체

### 4.2 복구
- [ ] 시작 시 WAL에서 레코드를 읽어 상태를 복원한다

---

## Phase 5: 내구성/복구 (B 시나리오)
> 정상 재시작 시 WAL replay로 상태 복구

### 5.1 재시작 후 데이터 유지 (B1)
- [ ] PUT 후 재시작 → GET으로 값 확인

### 5.2 여러 업데이트 후 재시작 (B2)
- [ ] 동일 키 여러 번 업데이트 후 재시작 → 마지막 값 유지

### 5.3 삭제 후 재시작 (B3)
- [ ] DEL 후 재시작 → 삭제 상태 유지

---

## Phase 6: 장애 타이밍 주입 (C 시나리오)
> Write Path 각 단계에서 크래시 시 동작 검증

### 6.1 WAL append 이전 크래시 (C1)
- [ ] 크래시 후 재시작 → 데이터 없음

### 6.2 WAL append 후 fsync 전 크래시 (C2)
- [ ] 미커밋 상태 검증

### 6.3 WAL fsync 후 MemTable 적용 전 크래시 (C3)
- [ ] 재시작 후 WAL replay로 복구

### 6.4 MemTable 적용 후 ack 전 크래시 (C4)
- [ ] 재시작 후 데이터 존재

### 6.5 ack 반환 후 크래시 (C5)
- [ ] 성공 ack의 의미 보장

### 6.6 DEL 장애 타이밍 (C6)
- [ ] 삭제 연산에 동일 패턴 적용

---

## Phase 7: WAL 손상/부분 레코드 (D 시나리오)
> 프레이밍/체크섬 검증

### 7.1 Partial record (D1)
- [ ] 끝부분 불완전 레코드 무시

### 7.2 체크섬 불일치 (D2)
- [ ] 손상 레코드 직전까지만 반영

### 7.3 잘못된 레코드 타입 (D3)
- [ ] 포맷 오류 시 중단

### 7.4 빈 WAL (D4)
- [ ] 빈 상태로 복구

---

## Phase 8: 체크포인트/로그 롤링 (E 시나리오)
> 스냅샷 + truncate 안전성

### 8.1 체크포인트 후 재시작 (E1)
- [ ] checkpoint만으로 복구

### 8.2 체크포인트 후 새 WAL (E2)
- [ ] checkpoint + 새 WAL replay

### 8.3 checkpoint.tmp 작성 중 크래시 (E3)
- [ ] 이전 checkpoint + WAL로 복구

### 8.4 checkpoint rename 직후 크래시 (E4)
- [ ] 새 checkpoint 유효성 확인

### 8.5 WAL 삭제 타이밍 크래시 (E5)
- [ ] 삭제 전/후 모두 안전

---

## Phase 9: 재적용 안전성 (F 시나리오)
> Replay 멱등성 검증

### 9.1 동일 WAL 여러 번 replay (F1)
- [ ] 매번 동일한 최종 상태

### 9.2 중복 레코드 처리 (F2)
- [ ] 중복 PUT도 올바른 결과

---

## Phase 10: 경계/예외 케이스 (G 시나리오)

### 10.1 빈 키/긴 키/큰 값 (G1)
- [ ] 경계값 테스트

### 10.2 디스크 쓰기 실패 (G2)
- [ ] 실패 시 요청 거부

### 10.3 동시성 (G3) - 선택
- [ ] 멀티 스레드 안전성

---

## Phase 11: 고급 엣지케이스 (H, I, J, K, L 시나리오)

### 11.1 Checkpoint 무결성 (H1, H2)
- [ ] 손상된 checkpoint 폴백

### 11.2 WAL 파서 방어 (I1, I2, I3)
- [ ] 비정상 length, 모순된 필드, 쓰레기 바이트

### 11.3 WAL 세그먼트 롤링 (J1, J2)
- [ ] 롤링 도중 크래시 안전성

### 11.4 ack 의미 강화 (K1, K2)
- [ ] fsync 실패 시 실패 반환, 재시도 안전성

### 11.5 읽기 일관성 (L1) - 선택
- [ ] 동시성 관측값 정의

---

## 진행 방식
1. 각 Phase 내에서 하나의 테스트 케이스를 선택
2. 실패하는 테스트 작성 (Red)
3. 최소한의 코드로 테스트 통과 (Green)
4. 필요시 구조 개선 (Refactor)
5. 커밋 (구조 변경과 동작 변경 분리)
6. 다음 테스트로 진행

---

## 현재 상태
- [x] 프로젝트 환경 세팅 완료 (Python 3.12 + pytest)
- [x] Phase 1 완료 - 메모리 기반 KV Store
- [ ] Phase 2 진행 중 - WAL 레코드 객체
- 참고: Phase 4에 임시 구현된 WAL 쓰기/읽기가 있음 (향후 교체 예정)
