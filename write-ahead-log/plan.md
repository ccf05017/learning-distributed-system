# WAL(Write-Ahead Log) 구현 계획

## 학습 목표
- WAL 기반 단일 노드 KV 스토어를 TDD로 구현하며 분산 시스템의 내구성(durability) 원리를 체득한다
- "로그가 디스크에 안전하게 기록되면 성공(ack)"이라는 커밋 기준을 실험으로 검증한다

---

## Phase 1: 기본 동작 (A 시나리오)
> 메모리 기반 KV 스토어의 기본 CRUD 동작

### 1.1 PUT/GET 기본 (A1)
- [x] 빈 스토어에서 PUT 후 GET으로 값 조회

### 1.2 UPDATE (A2)
- [x] 동일 키에 덮어쓰기 후 최신 값 반환

### 1.3 DELETE (A3)
- [x] 키 삭제 후 존재하지 않음 확인

### 1.4 다중 키 독립성 (A4)
- [x] 여러 키가 서로 독립적으로 동작

---

## Phase 2: WAL 기본 구조
> append-only 로그 파일 구조 및 레코드 포맷

### 2.1 WAL 쓰기
- [ ] PUT 수행 시 WAL 파일에 레코드가 기록된다
- [ ] DEL 수행 시 WAL 파일에 레코드가 기록된다
- [ ] 정상 종료 시 버퍼의 모든 데이터가 디스크에 flush되고 파일이 닫힌다

### 2.2 WAL 읽기
- [ ] WAL 파일에서 레코드를 순차적으로 읽을 수 있다
- [ ] 읽은 레코드로 상태를 복원할 수 있다

### 2.3 레코드 무결성
- [ ] 레코드에 체크섬이 포함된다
- [ ] 읽기 시 체크섬으로 손상 여부를 검증한다

---

## Phase 3: 내구성/복구 (B 시나리오)
> 정상 재시작 시 WAL replay로 상태 복구

### 3.1 재시작 후 데이터 유지 (B1)
- [ ] PUT 후 재시작 → GET으로 값 확인

### 3.2 여러 업데이트 후 재시작 (B2)
- [ ] 동일 키 여러 번 업데이트 후 재시작 → 마지막 값 유지

### 3.3 삭제 후 재시작 (B3)
- [ ] DEL 후 재시작 → 삭제 상태 유지

---

## Phase 4: 장애 타이밍 주입 (C 시나리오)
> Write Path 각 단계에서 크래시 시 동작 검증

### 4.1 WAL append 이전 크래시 (C1)
- [ ] 크래시 후 재시작 → 데이터 없음

### 4.2 WAL append 후 fsync 전 크래시 (C2)
- [ ] 미커밋 상태 검증

### 4.3 WAL fsync 후 MemTable 적용 전 크래시 (C3)
- [ ] 재시작 후 WAL replay로 복구

### 4.4 MemTable 적용 후 ack 전 크래시 (C4)
- [ ] 재시작 후 데이터 존재

### 4.5 ack 반환 후 크래시 (C5)
- [ ] 성공 ack의 의미 보장

### 4.6 DEL 장애 타이밍 (C6)
- [ ] 삭제 연산에 동일 패턴 적용

---

## Phase 5: WAL 손상/부분 레코드 (D 시나리오)
> 프레이밍/체크섬 검증

### 5.1 Partial record (D1)
- [ ] 끝부분 불완전 레코드 무시

### 5.2 체크섬 불일치 (D2)
- [ ] 손상 레코드 직전까지만 반영

### 5.3 잘못된 레코드 타입 (D3)
- [ ] 포맷 오류 시 중단

### 5.4 빈 WAL (D4)
- [ ] 빈 상태로 복구

---

## Phase 6: 체크포인트/로그 롤링 (E 시나리오)
> 스냅샷 + truncate 안전성

### 6.1 체크포인트 후 재시작 (E1)
- [ ] checkpoint만으로 복구

### 6.2 체크포인트 후 새 WAL (E2)
- [ ] checkpoint + 새 WAL replay

### 6.3 checkpoint.tmp 작성 중 크래시 (E3)
- [ ] 이전 checkpoint + WAL로 복구

### 6.4 checkpoint rename 직후 크래시 (E4)
- [ ] 새 checkpoint 유효성 확인

### 6.5 WAL 삭제 타이밍 크래시 (E5)
- [ ] 삭제 전/후 모두 안전

---

## Phase 7: 재적용 안전성 (F 시나리오)
> Replay 멱등성 검증

### 7.1 동일 WAL 여러 번 replay (F1)
- [ ] 매번 동일한 최종 상태

### 7.2 중복 레코드 처리 (F2)
- [ ] 중복 PUT도 올바른 결과

---

## Phase 8: 경계/예외 케이스 (G 시나리오)

### 8.1 빈 키/긴 키/큰 값 (G1)
- [ ] 경계값 테스트

### 8.2 디스크 쓰기 실패 (G2)
- [ ] 실패 시 요청 거부

### 8.3 동시성 (G3) - 선택
- [ ] 멀티 스레드 안전성

---

## Phase 9: 고급 엣지케이스 (H, I, J, K, L 시나리오)

### 9.1 Checkpoint 무결성 (H1, H2)
- [ ] 손상된 checkpoint 폴백

### 9.2 WAL 파서 방어 (I1, I2, I3)
- [ ] 비정상 length, 모순된 필드, 쓰레기 바이트

### 9.3 WAL 세그먼트 롤링 (J1, J2)
- [ ] 롤링 도중 크래시 안전성

### 9.4 ack 의미 강화 (K1, K2)
- [ ] fsync 실패 시 실패 반환, 재시도 안전성

### 9.5 읽기 일관성 (L1) - 선택
- [ ] 동시성 관측값 정의

---

## 진행 방식
1. 각 Phase 내에서 하나의 테스트 케이스를 선택
2. 실패하는 테스트 작성 (Red)
3. 최소한의 코드로 테스트 통과 (Green)
4. 필요시 구조 개선 (Refactor)
5. 커밋 (구조 변경과 동작 변경 분리)
6. 다음 테스트로 진행

---

## 현재 상태
- [x] 프로젝트 환경 세팅 완료 (Python 3.12 + pytest)
- [ ] Phase 1 시작 대기
