# 2계층 산출물 템플릿 (Layer 0 + Layer 1)

## Layer 1: Skill Spec (AI 적용용 컨텍스트 패키지)
> 목적: 이 문서는 “회고”가 아니라, **유사 문제가 다시 발생했을 때 AI에게 즉시 주입해 올바른 산출물을 만들게 하는 실행 지향 컨텍스트**다.  
> 원칙: AI가 코드를 “대신 생산”하게 두지 말고, **내가 검증 가능한 절차(TDD/테스트/반례)를 빠르게 수행**하도록 돕는 정보로 구성한다.

### 0) Mode (이 Skill의 성격)
- [ ] Decision Skill (도입 판단/설계 선택지 확장)
- [ ] Implementation Skill (구현 재현/세부 설계)
> 권장: 대부분은 Decision Skill로 작성하고, 구현 디테일은 별도 문서/코드 링크로 격리한다.

### 1) Skill ID / 한 줄 정의
- Skill ID:
- 한 줄 정의:
  - (예) “현재 시스템의 커밋 경계/장애 모델을 바탕으로 WAL(또는 대안) 도입 여부를 판단하고, 최소 설계 옵션과 검증 시나리오를 제시하는 절차”

### 2) Trigger (언제 이 스킬을 꺼내 쓰나)
- 적용 상황(증상/요구):
  - (예) “재시작/크래시 후에도 ‘성공 응답(ack)’의 결과가 반드시 유지되어야 함”
  - (예) “쓰기 경로가 여러 단계라 중간 실패 시 ‘유령 성공/유령 실패’가 생김”
  - (예) “현재 저장 방식이 append-only 로그/체크포인트/replay와 잘 맞을 것 같음”
  - (예) “WAL/Outbox/트랜잭션 등 설계 선택지를 넓히고 싶음”
- 포함 조건(이 스킬이 유효한 범위):
  - (예) “ack(성공)의 의미를 명확히 정의할 수 있음”
  - (예) “장애 모델을 최소 1개는 고정할 수 있음(process kill vs power loss 등)”
  - (예) “쓰기 경로를 단계로 나눠 설명할 수 있음”
- 제외 조건(다른 스킬/설계를 써야 하는 경우):
  - (예) “합의/복제/리더 선출 등 분산 합의가 핵심”
  - (예) “정확히 한 번(exactly-once) 의미론이 최우선”
  - (예) “멀티 writer 고성능이 즉시 필요(그룹 커밋/백그라운드 flush/락 프리)”

### 3) Inputs (AI에게 제공해야 하는 입력)
- 필수 입력:
  - 요구사항/성공 기준(테스트 가능 형태): “ack가 성공이면, 재시작 후에도 반드시 관측되어야 한다” 같은 문장
  - 현재 write path 단계(텍스트로 충분): 예) validate → log_append → flush → fsync → mem_apply → ack
  - 장애/실패 모델: process kill? power loss? `fsync` 실패 가능? 재시도 정책?
  - 일관성/가시성 요구: 읽기에서 dirty read 허용? read-your-writes 필요?
  - 제약(성능, 지연, 저장매체, 언어/런타임, OS):
- 선택 입력(있으면 정확도가 크게 오르는 것):
  - 현재 저장소/트랜잭션 존재 여부: DB 트랜잭션/메시지 브로커/원자적 rename 등
  - 데이터 포맷/프레이밍: newline vs length-prefix, checksum/CRC, 최대 레코드 크기
  - 관측 수단: 로그/메트릭/트레이스(“몇 번째 단계에서 실패했는지”)
- 입력이 불충분할 때 AI가 해야 할 일(기본 정책):
  - “가정(ack 의미/장애 모델)을 명시하고, 가정별로 다른 선택지를 분리”
  - “결정의 근거가 되는 최소 시나리오 테스트/실험을 먼저 제안”

### 4) Outputs (AI가 만들어야 하는 산출물)
- 산출물 타입(해당되는 것만 선택):
  - [ ] 도입 판단(추천/보류/비추천 + 근거)
  - [ ] 설계 선택지(최소 설계 + 대안 비교)
  - [ ] 검증 시나리오(프로젝트-중립 템플릿)
  - [ ] 구현 코드(패치/PR 단위)
  - [ ] 테스트 추가/수정(단위/통합/회귀)
- 성공 기준(명시적으로):
  - “도입 판단이 ‘불변조건/실패모드/검증’까지 포함한 근거 기반 결론”
  - “선택한 커밋 규약(ack 의미)이 재시작 시나리오로 검증 가능”

### 5) Invariants & Constraints (절대 조건 / 제약)
- 절대 불변조건(깨지면 실패):
  - (예) “성공 ack의 의미는 재시작 후에도 유지”
  - (예) “`fsync` 실패 의미(no-trace vs unknown vs fatal)를 계약으로 고정”
  - (예) “손상/부분 레코드에서 정책(중단/무시)을 명시하고 침묵 오류 금지”
- 제약 조건:
  - 성능/지연:
  - 저장/파일 시스템 제약:
  - 라이브러리/프레임워크 제약:
- 허용되는 트레이드오프(명시):
  - (예) “성능보다 ‘성공의 의미’ 명확화 우선”
  - (예) “단일 writer 가정으로 동시성 범위 제한”
  - (예) “unknown을 허용하면 멱등/재시도 비용 증가”

### 6) Procedure (AI가 따라야 할 절차 / 체크리스트)
- 표준 절차(짧고 결정적으로):
  1. “성공 ack의 의미”를 1문장으로 고정(재시작 후 관측까지 포함)
  2. 현재 write path를 단계로 분해하고, 단계별 실패모드를 나열
  3. 도입 후보를 3개 이상으로 확장(WAL, DB 트랜잭션, outbox, 단일 writer+큐 등)
  4. `fsync` 실패 의미(no-trace/unknown/fatal)를 결정하고, 그 선택의 비용을 명시
  5. 최소 검증 시나리오(재시작/크래시/손상) 3~5개를 프로젝트-중립 템플릿으로 작성
- 의사결정 분기(필요 시):
  - if “성공이 꼭 durable이어야 함” → 커밋 포인트를 fsync/트랜잭션으로 고정
  - if “`fsync` 실패를 no-trace로 강제” → rollback/truncate(단일 writer 전제) 또는 fatal 고려
  - if “레코드 경계/partial이 문제” → length-prefix framing + checksum + 상한 검토
  - if “성능 요구가 올라감” → group commit/async flush는 별도 트랙으로 분리

### 7) Verification (검증: 반드시 통과해야 하는 것)
- 필수 검증 시나리오(프로젝트-중립 템플릿):
  - “성공 ack 후 재시작 → 반드시 반영됨”
  - “ack 전 크래시 → 반영되면 안 됨(또는 계약대로)”
  - “tail partial/손상 데이터 → 정책대로 중단/무시, prefix는 보존”
  - “`fsync` 실패 → 계약(no-trace/unknown/fatal)과 모순 없는 관측”
- 테스트가 보장하지 못하는 것(과신 방지, 1~2줄):
  - “SIGKILL은 power loss를 완전히 대체하지 못함”

### 8) Failure Modes & Debug (실패 모드 / 디버깅 지침)
- Top 실패 모드 1:
  - 증상:
  - 가능한 원인(가설 3개):
  - 확인 순서(최소 단계):
  - 수정 후 추가할 회귀 테스트:
- Top 실패 모드 2:
  - (동일 양식)
- Top 실패 모드 3:
  - (동일 양식)

### 9) Anti-patterns (금지 패턴)
- 금지 1: (예) “테스트 없이 코드만 확장”
- 금지 2: (예) “ack를 flush 기준으로 반환”
- 금지 3: (예) “손상 레코드 이후도 계속 진행(침묵 오류)”

### 10) Prompt Capsule (AI에게 붙여넣는 최적 요청문)
- 캡슐 프롬프트 1: “도입 판단/설계 선택지 확장형”
  - 템플릿:
    - “현재 시스템의 write path(단계), 성공 ack 의미, 장애 모델(process kill/power loss), `fsync` 실패 가능성, 읽기 일관성 요구를 줄게.
      이 상황에서 WAL(쓰기 전 커밋/로그 기반 복구)을 도입하는 게 적절한지 판단해줘.
      (1) 추천/보류/비추천 결론, (2) 최소 설계 옵션(커밋 포인트/프레이밍/체크포인트/동시성), (3) 대안 2~3개 비교, (4) 최소 검증 시나리오(재시작/크래시/손상)까지 제시해줘.”
- 캡슐 프롬프트 2: “디버깅/원인 분석형”
  - 템플릿:
    - “현재 실패 증상과 로그/테스트 결과를 기반으로 원인 가설 3개를 우선순위로 제시하고,
      각 가설을 반증/확인할 수 있는 최소 실험(테스트/로그)을 제안해줘.”
- 캡슐 프롬프트 3: “리팩토링/품질 강화형”
  - 템플릿:
    - “동작 변경 없이 구조만 개선하는 리팩토링을 제안해줘. 변경 전후 동일성을 보장할 테스트(또는 스냅샷)를 함께 제시해줘.”
- (선택) 캡슐 프롬프트 4: “구현/테스트 생성형”
  - 템플릿:
    - “다음 제약/불변조건을 지키면서, 먼저 실패하는 테스트를 제안하고 그 테스트를 통과시키는 최소 구현을 제시해줘.
      (1) 가정 목록, (2) 검증 계획, (3) 실패 모드/회귀 테스트까지 포함해줘.”
- AI 금지 행동(명시):
  - (예) “불확실한 내용을 단정”
  - (예) “테스트 없이 대규모 코드 생성”
  - (예) “제약/불변조건을 무시한 최적화 제안”

### 11) Minimal Examples (최소 예제)
- 성공 예제(입력 → 기대 결과):
  - 입력:
  - 기대 결과:
  - 체크 포인트:
- 실패 예제(입력 → 실패 양상 → 기대 처리):
  - 입력:
  - 실패 양상:
  - 기대 처리:

---

## 저장/동기화 규칙 (권장)
- 폴더/네이밍
  - /skills/{domain}/{topic}/{YYYY-MM-DD}-{slug}/
- 최소 파일 구성
  - meta.md
  - layer_0.md
  - layer_1.md (이 문서)
  - (선택) llm_meta.md
  - (선택) notes/ (실험 로그, 실패 기록)
  - (선택) src/ (코드, 필요 시)
  - (선택) tests/ (테스트, 필요 시)
- 전역 색인(권장)
  - skills/_index.md (meta.md 링크 모음)
- 청킹(검색/RAG 대비)
  - Layer 1은 2~11 섹션 단위로 독립적으로 참조 가능하게 작성
  - Verification / Failure Modes / Prompt Capsule은 반드시 독립 섹션으로 유지(재사용성 극대화)
